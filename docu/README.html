<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>MrHTTPD README</title><meta name="generator" content="DocBook XSL Stylesheets V1.76.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="article" title="MrHTTPD README"><div class="titlepage"><div><div><h2 class="title"><a name="d53e1"></a>MrHTTPD README</h2></div><div><div class="author"><h3 class="author"><span class="firstname">Dr. Martin</span> <span class="surname">Rogge</span></h3><div class="affiliation"><span class="shortaffil">martin_rogge@users.sourceforge.net<br></span></div></div></div><div><p class="pubdate">2011-12-06</p></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d53e15">Welcome</a></span></dt><dt><span class="section"><a href="#d53e32">Quick Installation Guide</a></span></dt><dt><span class="section"><a href="#d53e51">Credits</a></span></dt><dt><span class="section"><a href="#d53e71">Concept &amp; Restrictions</a></span></dt><dt><span class="section"><a href="#d53e78">Background &amp; History</a></span></dt><dt><span class="section"><a href="#d53e89">Installation</a></span></dt><dt><span class="section"><a href="#d53e302">Starting and Stopping</a></span></dt><dt><span class="section"><a href="#d53e328">Performance</a></span></dt></dl></div><div class="section" title="Welcome"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d53e15"></a>Welcome</h2></div></div><div></div></div><p>Welcome to MrHTTPD. You can read it as Mr HTTPD if you like,
    although in reality the name refers to my initials. ;-)</p><p>MrHTTPD is maintained and copyrighted by Martin Rogge. The software
    is licensed to you under the GNU GENERAL PUBLIC LICENSE. The complete
    wording of the GPL is available in the file COPYING. I would also
    appreciate if you sent me a short email in case you find this software
    useful and deploy or modify it for any purpose. My email address is
    <code class="email">&lt;<a class="email" href="mailto:martin_rogge@users.sourceforge.net">martin_rogge@users.sourceforge.net</a>&gt;</code>.</p><p>The MrHTTPD home page is <a class="ulink" href="http://sourceforge.net/projects/mrhttpd" target="_top">http://sourceforge.net/projects/mrhttpd</a>.</p><p>Before we get into more detail, here is the quick installation guide
    for the impatient reader:</p></div><div class="section" title="Quick Installation Guide"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d53e32"></a>Quick Installation Guide</h2></div></div><div></div></div><p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Review mrhttpd.conf</p></li><li class="listitem"><p>./configure</p></li><li class="listitem"><p>make</p></li><li class="listitem"><p>as root: make install</p></li></ol></div></p><p>NB: you can skip step 2 and 3 if you feel lucky</p></div><div class="section" title="Credits"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d53e51"></a>Credits</h2></div></div><div></div></div><p>MrHTTPD started as a modification of an existing open source
    project, called GazTek HTTP Daemon (ghttpd for short). The GazTek HTTP
    Daemon is copyrighted under the GPL by Gareth Owen
    (<code class="email">&lt;<a class="email" href="mailto:gaz@athene.co.uk">gaz@athene.co.uk</a>&gt;</code>), last available under <a class="ulink" href="http://members.xoom.com/gaztek" target="_top">http://members.xoom.com/gaztek</a>.</p><p>In the meantime MrHTTPD has evolved significantly and the source
    code bears little or no resemblance to ghttpd. Also the runtime behaviour
    shows fast performance and enterprise strength stability.</p><p>The documentation you are reading right now has mostly been written
    in plain text and incrementally extended over various MrHTTPD releases.
    Beginning with release 2.1.0 the original documentation has been migrated
    to DocBook format. This move was prompted by practical as well as
    professional considerations, since I work in software development and I am
    currently concerned with questions of text and documentation management.
    For editing the DocBook version of this documentation I have been using
    the <a class="ulink" href="http://www.xmlmind.com/" target="_top">XML Mind</a> software under
    the personal edition license. The software is highly recommendable for
    users new to DocBook or XML in general.</p><p>I am currently still experimenting with different tool chains to
    produce suitable output formats from the DocBook original. The output
    quality is not always to my liking, and I still need to fix the plain text
    version manually for better readability. Nonetheless I am confident I will
    solve those issues as I get more familiar with the whole concept.
    ;-)</p></div><div class="section" title="Concept &amp; Restrictions"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d53e71"></a>Concept &amp; Restrictions</h2></div></div><div></div></div><p>MrHTTPD is a threaded web server that is lightning fast, simple,
    robust, secure and has a very small memory footprint. The binary is 15 to
    20 kilobytes in size, depending on configuration and CPU architecture.
    MrHTTPD serves files at 3 to 4 times the throughput of Apache and runs CGI
    scripts. It is not designed to implement the full HTTP protocol. For
    instance, MrHTTPD does not implement HTTP methods other than GET. Since
    version 2.0 MrHTTPD supports HTTP Keep-Alive.</p><p>Having started as a Linux specific project taking advantage of a few
    Linux specific featurs, the coding should be portable to other operating
    systems by now. The only caveat at this stage is: it has never been tested
    by me. ;-)</p></div><div class="section" title="Background &amp; History"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d53e78"></a>Background &amp; History</h2></div></div><div></div></div><p>The reason I started working on MrHTTPD was that I needed a web
    server providing simple services in my home local area network. In
    particular, it had to serve static files and run Perl scripts on my
    internet router which was a self-made and highly specialised Linux system.
    In fact, I had previously installed the Apache web server on the internet
    router and run it for years. Functionally, I have never had any reason to
    complain about Apache. The only reason for moving away from Apache is that
    it is an over-dimensioned solution for my requirements.</p><p>Not knowing much about socket programming in the beginning, I
    started experimenting with various open source web servers. Whilst many of
    them were inherently unstable and of bad performance I could learn about
    the basic structure of a web server. This excercise led to the first
    usable version of MrHTTPD which was rock solid and performing well in my
    local area network.</p><p>Eventually competitiveness got the better of me and I compared
    benchmark results with Apache. The astounding result was, despite being so
    much more concise, MrHTTPD would only reach half the speed of Apache in
    serving files. The reason was, MrHTTPD would fork a new process for every
    incoming connection, that is one for every GET request. Apache, on the
    other hand, relies on a number of already forked worker processes and
    distribution of work via inter-process communication. So I took up the
    gauntlet, did some reading about threads and finally transformed the
    server engine into a fully threaded design. The result was a speed
    increase by more than factor four when serving static files. MrHTTPD was
    able to outperform the Apache server even when the latter used HTTP
    Keep-Alive (a feature that MrHTTP offers only since version 2.0).</p><p>Note, however, that the high speed transfer only applies to serving
    static files. CGI programs are always started in a separate process (both
    by Apache and MrHTTPD) and they are usually time consuming. I have not
    implemented other protocols like FastCGI because so far I had no use for
    it.</p></div><div class="section" title="Installation"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d53e89"></a>Installation</h2></div></div><div></div></div><p>MrHTTPD is configured at compile time and only at compile time. This
    (and the small size) makes it suitable for embedded systems.</p><p>In order to configure MrHTTPD you load the file mrhttpd.conf into an
    editor. The file distributed with MrHTTPD contains explanations of the
    possible settings as part of the commentary.</p><p>In general, the configuration file defines pairs of variables and
    their values separated by a "=" character. The configuration file is
    included in bash scripts and make files. This means the file must fulfil
    the syntactical requirements of both applications. For instance, bash
    requires that there be no spaces around the "=" sign.</p><p>Let us now go through the list of variables. Note that some of these
    variables have become optional in v2.0 and will either default to some
    useful value, or disable the compilation of the associated feature. For
    details please refer to the sample configuration file.</p><p><div class="variablelist"><dl><dt><span class="term">SYSTEM_USER</span></dt><dd><p>defines the user account under which MrHTTPD will run. Note:
            If MrHTTPD is configured to listen at a non-privileged port it
            need not be started as root. However, if it is started as root you
            should specify a user with restricted access rights here.</p></dd><dt><span class="term">SERVER_ROOT</span></dt><dd><p>specifies the directory that will become the chroot jail of
            the server. All other paths with the exception of BIN_DIR are
            therefore relative to SERVER_ROOT. Be aware that a chroot jail can
            be very restrictive. In particular all your document files and all
            binaries and libraries required for running external programs must
            be replicated in the chroot jail.</p></dd><dt><span class="term">SERVER_PORT</span></dt><dd><p>defines the TCP port the server is listening on. The
            standard for the HTTP protocol is port 80, but you can use any
            other port if you like. It is quite possible to test one version
            of MrHTTPD on a test port while the productive web server listens
            on port 80 at the same time.</p></dd><dt><span class="term">SERVER_NAME</span></dt><dd><p>defines the name of the server in the sense of the host
            name. This is different from the "Server" attribute in the HTTP
            header which is hardcoded to "MrHTTPD/2.2.0".</p></dd><dt><span class="term">SERVER_DOCS</span></dt><dd><p>defines the root directory for internal files. Internal
            files are documents like the 404 error page.</p></dd><dt><span class="term">BIN_DIR</span></dt><dd><p>defines the installation directory for the binary. This is
            the only directory not affected by SERVER_ROOT since it is not
            runtime relevant.</p></dd><dt><span class="term">DOC_DIR</span></dt><dd><p>defines the root directory for all static files (HTML, CSS,
            JPG, etc.), ie. the actual productive content of the web
            server.</p></dd><dt><span class="term">CGI_URL</span></dt><dd><p>defines the URL component indicating that the resource is a
            CGI script rather than a static file. Whenever MrHTTPD finds this
            component at the beginning of the resource path, it assumes the
            resource is an executable CGI script.</p></dd><dt><span class="term">CGI_DIR</span></dt><dd><p>defines the root directory for CGI scripts.</p></dd><dt><span class="term">DEFAULT_INDEX</span></dt><dd><p>defines the name of the default file in a directory.
            Typically you use "index.html" or similar. MrHTTPD will serve this
            file if no file name is specified in the URL. For example, if a
            client requests http://server/path/ MrHTTPD will try to send
            http://server/path/index.html.</p></dd><dt><span class="term">PRAGMA</span></dt><dd><p>specifies an optional Pragma parameter that is sent with
            every HTTP reply. A typical value is "no-cache" if you want to
            suppress caching by proxy servers and frontends.</p></dd><dt><span class="term">LOG_LEVEL</span></dt><dd><p>determines the amount of information saved in the log file.
            Note: the higher the level the more code is generated. If you
            specify a log level 0, all routines related to log generation,
            file handling etc. are omitted from the compilation
            process.</p><p>The meaning of the values is as follows:</p><div class="variablelist"><dl><dt><span class="term">LOG_LEVEL=0</span></dt><dd><p>no log entries are created.</p></dd><dt><span class="term">LOG_LEVEL=1</span></dt><dd><p>additionally, all rejected requests are logged</p></dd><dt><span class="term">LOG_LEVEL=2</span></dt><dd><p>additionally, all accepted requests are logged</p></dd><dt><span class="term">LOG_LEVEL=3</span></dt><dd><p>additionally, every unsuccessful reply is
                  logged</p></dd><dt><span class="term">LOG_LEVEL=4</span></dt><dd><p>additionally, every successful reply is logged</p></dd></dl></div></dd><dt><span class="term">LOG_FILE</span></dt><dd><p>defines the file name used for saving the logs.</p></dd><dt><span class="term">EXT_FILE_CMD</span></dt><dd><p>specifies a binary that is used to determine the mime type
            of a resource. A typical binary would be the file(1) command. Note
            that the external file command is called only after evaluating the
            file suffix according to a list compiled into MrHTTPD. The obvious
            reason is the performance impact of an external call.</p><p>The external file command is always called with parameters
            "-b --mime-type". If you do not want that, you need to specify a
            shell script stripping the first two parameters.</p><p>Note: the external file command and all its dependencies are
            relative to SERVER_ROOT. If you use SERVER_ROOT you will probably
            need to copy the following files into the chroot jail (your
            mileage may vary):</p><div class="itemizedlist"><ul class="itemizedlist" type="none"><li class="listitem" style="list-style-type: none"><p>usr/bin/file</p></li><li class="listitem" style="list-style-type: none"><p>usr/lib/libmagic.so.1</p></li><li class="listitem" style="list-style-type: none"><p>usr/lib/libz.so.1</p></li><li class="listitem" style="list-style-type: none"><p>lib/ld-linux.so.2</p></li><li class="listitem" style="list-style-type: none"><p>lib/libc.so.6</p></li><li class="listitem" style="list-style-type: none"><p>etc/file/magic/*</p></li></ul></div></dd><dt><span class="term">SENDFILE</span></dt><dd><p>chooses which implementation is used for sending files. The
            choice is between a routine in user space and the kernel function
            sendfile(). Whilst the latter promises better performance and
            lower cpu load, you might want to choose the user space routine
            for trouble shooting. Also, on operating systems other than Linux
            you need to select the user space routine.</p></dd><dt><span class="term">QUERY_HACK</span></dt><dd><p>is an option for the method of processing query strings. If
            this variable exists the query string of a resource will be
            interpreted as part of the file name, provided the resource begins
            with the string in QUERY_HACK.</p><p>Example: assuming a request for a resource
            <code class="filename">index.html?sorted=yes</code>. Normally the server
            will read the file <code class="filename">index.html</code>. The query
            string <code class="filename">sorted=yes</code> will be omitted. If the
            resource is a CGI script the query string will be passed in the
            environment string QUERY. If you specify QUERY_HACK=index, the
            processing will be different and the server will read the file
            <code class="filename">index.html?sorted=yes</code>.</p><p>The option is named a hack because it is a violation of the
            HTTP specification. It is, however, useful when you have mirrored
            dynamic resources using <code class="filename">wget</code>, and
            <code class="filename">wget</code> has created filenames containing the
            query part.</p></dd></dl></div></p><p>After the configuration step say</p><p><pre class="programlisting">./configure</pre></p><p>or</p><p><pre class="programlisting">make config.h</pre></p><p>Either command will start the script "configure" which will do some
    basic sanity checks on mrhttpd.conf and create the C include
    "config.h".</p><p>After that you may call</p><p><pre class="programlisting">make</pre></p><p>and finally</p><p><pre class="programlisting">make install</pre></p><p>NB: You need to be root for the latter. As an experienced user you
    may feel safer to look at the Makefile and do the installation manually.
    It is not rocket science.</p></div><div class="section" title="Starting and Stopping"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d53e302"></a>Starting and Stopping</h2></div></div><div></div></div><p>MrHTTPD is always started in standalone mode and without parameters.
    It will send itself into the background. The foreground process will exit
    immediately. You can now do a test run from a local web browser by
    pointing it towards http://localhost/ (or whatever server, port and
    resource is appropriate in your case).</p><p>MrHTTPD will not read any configuration file at runtime. All
    parameters have been compiled into the binary. For that reason MrHTTPD
    will accept a SIGHUP signal but it will not do anything.</p><p>MrHTTPD can be stopped by sending it the SIGINT or the SIGTERM
    signal, ie. you can say any of the following:</p><div class="itemizedlist"><ul class="itemizedlist" type="none"><li class="listitem" style="list-style-type: none"><p>kill -2 &lt;pid&gt;</p></li><li class="listitem" style="list-style-type: none"><p>kill -15 &lt;pid&gt;</p></li><li class="listitem" style="list-style-type: none"><p>killall -2 mrhttpd</p></li><li class="listitem" style="list-style-type: none"><p>killall -15 mrhttpd</p></li></ul></div><p>After receiving those signals, mrhttpd will release the socket and
    wait 5 seconds for threads and child processes to finish. So you can start
    another server listening on the same port straight away. Please avoid
    sending a SIGKILL signal unless there is a good reason. A typical control
    script called rc.httpd is provided with mrhttpd. If you want to use it in
    a standard location like /etc/rc.d/ you need to copy it manually.</p><pre class="programlisting">#!/bin/bash
#
# Start the web server
#

case "$1" in
   'start')
      /usr/local/sbin/mrhttpd
      ;;
   'stop')
      killall -2 mrhttpd
      ;;
   'restart')
      killall -2 mrhttpd
      sleep 1
      /usr/local/sbin/mrhttpd
      ;;
   *)
      echo "usage: $0 start|stop|restart"
esac</pre></div><div class="section" title="Performance"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d53e328"></a>Performance</h2></div></div><div></div></div><p>Performance testing is a difficult topic. Particularly when you
    venture into extreme load scenarios.However, in order to detect
    regressions and ensure stability in normal operations I now routinely
    execute a high load performance test script as part of every release of
    MrHTTPD.</p><p>For release 2.2 I have run the tests on my main development machine
    which has an Intel Core i3-530 CPU at 3500 MHz and 4GB of RAM. The CPU
    offers two cores with hyperthreading, resulting in 4 logical processors.
    The operating system was Slackware 13.37 (plus a few upgrades from
    Slackware Current). I have run all tests on two kernels, namely on vanilla
    3.1.4 and on 3.1.4-ck2, the latter containing the BFS scheduler and the
    interactivity patches provided by <a class="ulink" href="http://ck-hack.blogspot.com/" target="_top">Con Kolivas</a>.</p><p>If you want to repeat my performance tests, please observe that
    logging has a noticable effect on the results under the extreme work loads
    created by the test. The results shown here have been obtained with
    logging disabled for all tested HTTP servers. I have included the test
    script <code class="filename">perftest.pl</code> in the subdirectory
    <code class="filename">extra</code> of the distribution. It requires the benchmark
    program <code class="filename">ab</code> which is part of the Apache
    distribution.</p><p>I have included the raw performance data obtained from the web
    servers Apache, Lighttpd and MrHTTPD in CSV format (comma separated
    values), as produced by the test script <code class="filename">perftest.pl</code>.
    I have also included a version in ODS format, as used by LibreOffice or
    OpenOffice Calc. The ODS version is particularly useful for filtering
    rows.</p><p>As I mentioned in the beginning, performance testing under extreme
    load is a difficult topic. I found I had to push certain system limits
    prior to be able to complete the test suite for concurrency levels above
    1000 (which for the machine in question is way beyond healthy anyway). In
    particular I needed to run the following commands beforehand:</p><p><pre class="programlisting">echo 65536 &gt; /proc/sys/net/ipv4/tcp_max_syn_backlog
echo 65536 &gt; /proc/sys/net/core/somaxconn
echo 65536 &gt; /proc/sys/net/core/netdev_max_backlog
echo 16777216 &gt; /proc/sys/net/core/rmem_max
echo 16777216 &gt; /proc/sys/net/core/wmem_max
echo 4096 87380 16777216 &gt; /proc/sys/net/ipv4/tcp_rmem
echo 4096 16384 16777216 &gt; /proc/sys/net/ipv4/tcp_wmem
echo 16384 &gt; /proc/sys/vm/min_free_kbytes
ulimit -n 65536
ulimit -i 65536
ulimit -u 65536</pre></p><p>But even then the kernel interfered when running the performance
    test for Apache and Lighttpd: the connection was dropped and a system
    message "Possible SYN flooding" was stored in the system log. From the
    kernel sources it appears this message is generated when the incoming
    connections are not accepted quickly enough by the listening server. Be it
    as it may, I could not find a solution and the corresponding results are
    therefore missing from the result set.</p><p>Looking at the results, it can be said that Apache is trailing
    behind in virtually all tests. For CGI scripts, Lighttpd seems to be the
    best performer overall, particularly on the vanilla kernel.</p><p>For static HTML pages, particularly when connections are kept alive,
    MrHTTPD wipes the floor with the competition. As an example look at the
    following result reading 1000000 static files at concurrency level
    100:</p><div class="informaltable"><table border="1"><colgroup><col><col><col><col><col><col></colgroup><thead><tr valign="middle"><th valign="middle">Kernel Version</th><th valign="middle">Server</th><th valign="middle">Keep-Alive</th><th valign="middle">Requests per second</th><th valign="middle">Rate</th><th valign="middle">Max. time [ms]</th></tr></thead><tbody><tr><td>3.1.4</td><td>Apache/2.2.21</td><td align="right">yes</td><td align="right">25427</td><td align="right">33388</td><td align="right">265</td></tr><tr><td>3.1.4</td><td>lighttpd/1.4.29</td><td align="right">yes</td><td align="right">54741</td><td align="right">68892</td><td align="right">6</td></tr><tr><td>3.1.4</td><td>MrHTTPD/2.2.0</td><td align="right">yes</td><td align="right">88898</td><td align="right">100888</td><td align="right">5</td></tr><tr><td>3.1.4-ck2</td><td>Apache/2.2.21</td><td align="right">yes</td><td align="right">43760</td><td align="right">57462</td><td align="right">17</td></tr><tr><td>3.1.4-ck2</td><td>lighttpd/1.4.29</td><td align="right">yes</td><td align="right">49227</td><td align="right">61652</td><td align="right">6</td></tr><tr><td>3.1.4-ck2</td><td>MrHTTPD/2.2.0</td><td align="right">yes</td><td align="right">163158</td><td align="right">185150</td><td align="right">2</td></tr></tbody></table></div><p>The throughput offered by MrHTTPD is three to four times higher than
    Apache and Lighttpd. Result sets at higher concurrency continue this
    trend, and at insane concurrency levels like 10000 or 20000 MrHTTPD is the
    only responsive server remaining.</p><p>The other stunning fact proven by these figures is the significant
    impact of the BFS CPU scheduler and other optimizations inherent in the CK
    patch, leading to almost twice the throughput compared to the vanilla
    kernel (which was btw configured to use the CFQ scheduler). This is even
    more surprising as the design goal of the CK patch is desktop
    interactivity rather than server throughput.</p><p>It is also noticable that a fully threaded design like MrHTTPD
    benefits particularly well from the CK patch, whereas the event-driven
    design of Lighttpd often seems to perform slightly better under the
    vanilla kernel.</p></div></div></body></html>